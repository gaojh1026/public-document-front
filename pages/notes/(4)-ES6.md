****



## 什么是ECMAscript

javascript的组成：[ECMAscript(ES6升级的部分)+dom+bom](// url.hostname
// 设置或获取URL中的hostname， 与host不同的是， hostname不包含端口
const myURL = new URL('https://example.org:81/foo');
console.log(myURL.hostname); //example.org)

ECMA欧洲计算机制造商协会制定了ECMAscript标准，ECMA-262

ECMAscript是ECMA组织制定的ECMA-262标准化下產生的一个脚本语言

TC39（ECMAscript发展委员会）在维护ECMA-262的标准，由各大浏览器产商组织而成的。

## ES6简介

*   ES6， 全称 ECMAScript 6.0 ，是一个==泛指==，含义是 JavaScript 的下一个版本标准，2015.06 发版。
*   ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有==类的概念==，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。
*   ES6是ECMAScript的升级版本，也就是说JavaScript的核心部分（句法）进行了升级，在ES6中==不包含DOM和BOM操作==。
*   我们在学习ES6课程内容中，包含了ES7/8/9/10/11的内容

## 环境对ES6的支持

浏览器对ES2015的支持情况

*    Chrome：51 版起便可以支持 97% 的 ES6 新特性。
*    Firefox：53 版起便可以支持 97% 的 ES6 新特性。
*    Safari：10 版起便可以支持 99% 的 ES6 新特性。
*    IE：Edge 15可以支持 96% 的 ES6 新特性。Edge 14 可以支持 93% 的 ES6 新特性。（IE7~11 基本不支持 ES6）
*   简单来说，我们的项目上线时，为了让兼容性更高，一般我们会对项目的JS文件的语法进行转化（ES5）。

服务器对ES2015的支持情况

*    Node.js：6.5 版起便可以支持 97% 的 ES6 新特性。（6.0 支持 92%）
*   大部分的ES6语法在新版本的node环境中都可以支持(99%)

## ECMAScript的版本

第一版本		97年			基本语法句法

....						

第五版本		09年			我们之前学习的JS语法

第六版本		15年			做出重大改变，加入新的语法特性

第七版本		16年			Array.includes() /Array.find()...Async/Await

第八版本		17年			Object.values()，Object.entries()...

第九版本		18年			for await of/命名捕获组

第十版本		19年			Array.flat()/Array.flatMap()/Object.fromEntries()...

第十一版本	20年			

...

## 包管理器

NPM 是 Node.js 标准的软件包管理器。在 2017 年 1 月时，npm 仓库中就已有超过 350000 个软件包，这使其成为世界上最大的单一语言代码仓库，并且可以确定几乎有可用于一切的软件包。它起初是作为下载和管理 Node.js 包依赖的方式，但其现在也已成为前端 JavaScript 中使用的工具。

cnpm 是 npm 的一个替代选择，yarn 也是 npm 的一个替代选择。

### 几种方案：

方案一：修改npm仓库地址为淘宝仓库地址

```js
# 修改npm下载的仓库地址
$ npm config set registry http://registry.npm.taobao.org/
# 改回原来的地址
$ npm config set registry https://registry.npmjs.org/
# 查看是否修改成功
$ npm config get registry
```

方案二：安装cnpm

```js
 $ npm install -g cnpm --registry=https://registry.npm.taobao.org
```

方案三：安装yarn

```js
$ npm install -g yarn --registry=https://registry.npm.taobao.org
```

### **npm依赖安装方式**

```js
//本地安装  安装到当前文件夹
$ npm install <module_name>
//带-g的为全局安装 全局使用（所有项目通用）一般为工具
$ npm install -g <module_name>
$ npm install --global <module_name>
//生产依赖  需要发布到生产环境的（发布）
$ npm install -S <module_name>
$ npm install --save <module_name>
//开发依赖 里面的插件只用于开发环境，不用于生产环境.
$ npm install -D <module_name>
$ npm install --save-dev <module_name>
//更新依赖
$ npm update <module_name>
//卸载依赖
$ npm uninstall  <module_name>
```

```
npm install 安装所有依赖
npm install --production 安装生产依赖
npm install xx --save 安装XX到生产环境依赖
npm install --save-dev 安装XX到开发环境依赖
```



### cnpm依赖安装方式（了解）

```js
//与npm的使用方式基本一致，只是前面的关键词为cnpm
$ cnpm install -g <module_name>
$ cnpm init
```

### **yarn依赖安装方式（了解）**

```js
//语法有变化
//安装
npm install -g yarn
//初始化项目
$ yarn init
//生产依赖
$ yarn add <module_name> 
//开发依赖
$ yarn add <module_name> --dev
//更新依赖
$ yarn update <module_name>
//删除依赖
$ yarn remove <module_name>
```

## 常用模块补充

更多模块可以前往node服务开发进行查看



## var、let、const

### `var`和`let`/`const`的区别:

>   1.  块级作用域
>   2.  不存在变量提升
>   3.  暂时性死区
>   4.  不可重复声明
>   5.  let、const声明的全局变量不会挂在顶层对象下面

### `const`命令两个注意点:

1.  `let`可以先声明稍后再赋值,而`const`在 声明之后必须马上赋值，否则会报错
2.  const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。

### let、const使用场景:

1.  `let`使用场景：变量，用以替代`var`。
2.  `const`使用场景：常量、声明匿名函数、箭头函数的时候。

### 为什么需要块级作用域?

ES5只有全局作用域和函数作用域，没有块级作用域。

这带来很多不合理的场景:

>   ***场景***
>
>   1.  内层变量可能覆盖外层变量
>   2.  用来计数的循环变量泄露为全局变量

不合理场景：

```js
var tmp = new Date();
function f() {
  console.log(tmp); // 想打印外层的时间作用域
  if (false) {
    var tmp = 'hello world'; // 这里声明的作用域为整个函数
  }
}
f(); // undefined
--------------------------------------------
var s = 'hello';
for (var i = 0; i < s.length; i++) {
  console.log(s[i]); // i应该为此次for循环使用的变量
}
console.log(i); // 5 全局范围都可以读到
```

### ==1、块级作用域==

##### 1、作用域

```js
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
    console.log(n); // 10 内层的n
  }
  console.log(n); // 5 当前层的n
}
```

##### 2、块级作用域任意嵌套

```
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错 读不到子作用域的变量
}}}};
复制代码
```

##### 3、真正使代码分割成块了

```
{
let a = ...;
...
}
{
let a = ...;
...
}
复制代码
```

以上形式，**可以用于测试一些想法，不用担心变量重名，也不用担心外界干扰**

##### **4.在块级作用域声明函数，最好使用匿名函数的形式**。

```js
if(true){
  let a = function () {}; // 作用域为块级 令声明的函数作用域范围更清晰
}
```

##### **5.ES6 的块级作用域**

**允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错**。

```js
// 报错
'use strict';
if (true)
  function f() {} // 我们需要给if加个{}
```




### 2、不存在变量提升

**变量提升的现象**：在同一作用域下，变量可以在声明之前使用，值为 undefined

ES5 时使用`var`声明变量，经常会出现变量提升的现象。

```js
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

### 3、暂时性死区：

只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，**只有等到声明变量的那一行代码出现，才可以获取和使用该变量**

```js
var tmp = 123; // 声明
if (true) {
  tmp = 'abc'; // 报错 因为本区域有tmp声明变量
  let tmp; // 绑定if这个块级的作用域 不能出现tmp变量
}
```

**暂时性死区和不能变量提升的意义在于:**

为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

### 4、不允许重复声明变量

>   在测试时出现这种情况:`var a= '声明';const a = '不报错'`，这种情况是因为babel在转化的时候，做了一些处理，在浏览器的控制台中测试，就成功报错

`let`、`const`不允许在相同作用域内，重复声明同一个变量

```js
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
```

### 5、let、const声明的全局变量不会挂在顶层对象下面

1.  浏览器环境顶层对象是: `window`
2.  node环境顶层对象是: `global`
3.  var声明的全局变量会挂在顶层对象下面，而let、const不会挂在顶层对象下面。如下面这个栗子

```js
var a = 1;
// 如果在 Node环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```




### const命令

1.  #### **一旦声明，必须马上赋值**

    ```js
    let p; var p1; // 不报错
    const p3 = '马上赋值'
    const p3; // 报错 没有赋值
    ```

2.  #### **const一旦声明值就不能改变**

    #### 简单类型:不能改动

    ```js
    const p = '不能改变';
    p = '报错'
    ```

    #### 复杂类型:变量指针不能变

    考虑如下情况：

    ```js
    const p = ['不能改动']
    const p2 = {
      name: 'OBKoro1'
    }
    p[0] = '不报错'
    p2.name = '不报错'
    p = ['报错']
    p2 = {
      name: '报错'
    }
    ```

    const所说的一旦声明值就不能改变，实际上指的是：**变量指向的那个内存地址所保存的数据不得改动**

    *   简单类型(number、string、boolean)：**内存地址就是值,即常量(一变就报错)**.

    *   复杂类型(对象、数组等)：**地址保存的是一个指针，`const`只能保证指针是固定的(总是指向同一个地址),它内部的值是可以改变的(不要以为const就安全了！)**

        所以只要不重新赋值整个数组/对象， 因为保存的是一个指针，所以对数组使用的`push`、`shift`、`splice`等方法也是允许的，你就是把值一个一个全都删光了都不会报错。

    >   复杂类型还有函数，正则等，这点也要注意一下。













## 解构

###  数组解构

（1）格式完全一样

```js
let nums = [1, [2, 3, [4, [5]]]];
let [a, [b, c, [d, [e]]]] = nums //得想清楚结构
console.log(a, b, c, d, e)
```

（2）完全解构

```js
let stus = ['zs', 'ls', 'ww', 'zs', 'ln']; //可以是某个模块导出的
let [name1, name2, name3, name4, name5] = stus;
console.log(name2)//ls
```



（3）不完全解构

```js
let [name1, name3] = stus;
console.log(name1, name3) //zs ls
```

（4）异常解构

```js
let [name1, name2, name3, name4, name5, name6] = stus;
console.log(name6) //undefined
```



### 对象解构

```js
//obj
var obj = {
    name: 'zs',
    age: 10,
    getName: function() {
        console.log('名字' + this.name);
    }
}
```

（1）混合解构

```js
var arr = [1, 2, obj];
var [a, b, { name }] = arr;
console.log(name) //zs  结构正确，就可以拿到
```

（2）完全解构

```js
let { name, age, getName } = obj; //对象解构的时候，可以不考虑顺序
console.log(name) //zs
```

（3）不完全解构

```js
let { name } = obj;
console.log(name); //zs
```

（4）异常解构

```js
let { sex } = obj;
console.log(sex) //undefinedd
```

### 字符串解构

```js
var str = "xiaoming"
```

以数组解构：

```js
var [a, b] = str; //如果利用数组结构字符串，会以下标进行解构
console.log(a, b); //x i
```

以对象解构属性：

```js
var { length, toString, valueOf } = str; //可以利用对象去解构字符串对象中的属性和方法
console.log(length, toString, valueOf) //8 [Function: toString] [Function: valueOf]
```



### 数值解构

```
var num = 123453333
```

以对象解构属性：（无数组）

```js
var { toString } = num; //数值类型也可以用对象进行解构，注意没有length属性
console.log(toString) //[Function: toString]
```



### 默认值

```js
var obj = {
    age: 10,
    getName: function() {
        console.log('名字' + this.name);
    }
}

var { age, name = "高佳辉" } = obj; //没有就用默认值
console.log(name, age) //高佳辉 10//可以不考虑解构顺序
```

```js
var arr = [1, 2, 3, 4, 5];
var [b = 9, d, e, f, g, h = 6] = arr; //数组中的解构顺序重要
console.log(h) //6
```





## 扩展运算符 （...)

可以将元素进行扩展或者聚合，一般情况下为扩展。配合解构进行使用。

### 数组中

#### (1)解构

```js
var arr = [1, 2, 3, 4, 5];
console.log(...arr); //1 2 3 4 5
```

#### (2)深拷贝

```js
var arr1 = [...arr];
console.log(arr1) //[ 1, 2, 3, 4, 5 ]
```

#### (3)合并操作 扩展

```
var arr2 = [...arr, 6, 7]
console.log(arr2)//[1, 2, 3, 4,5, 6, 7]
```

#### (4)聚合

左边扩展,右边聚合

```js
var [a, ...b] = arr; //余下未解构的成员都在b变量中*
console.log(b) //[ 2, 3, 4, 5 ]
```

### 字符串

#### (1)解构

```js
var str = "hello";
console.log(...str) //h e l l o
console.log([...str]) //[ 'h', 'e', 'l', 'l', 'o' ]    字符串类型拆出来还是字符串类型
```

#### (2)合并操作

```js
var arr3 = [...str, "xm"];
console.log(arr3) //[ 'h', 'e', 'l', 'l', 'o', 'xm' ]
```

####  (3)聚合

```
var [c, ...d] = str;
console.log(c, d) //h [ 'e', 'l', 'l', 'o' ]
```

### 对象中

```js
var obj = {
    name: 'ls',
    age: 18,
    getName: function() {
        console.log(this.name)
    }
}
```

#### (1)合并

```js
var new_obj = { //合并
        ...obj,
        sex: 'female',
        getAge() {}
    }
    console.log(new_obj)

    //运行结果:
    {
        name: 'ls',
        age: 18,
        getName: [Function: getName],
        sex: 'female',
        getAge: [Function: getAge]
      }
```

#### (2)简单的拷贝,深拷贝

```
var new_obj2 = {...obj }
```

####   (3)解构

```js
var { name, ...o } = new_obj;
console.log(name, o)

    //运行结果:
    ls 
    {
        age: 18,
        getName: [Function: getName],
        sex: 'female',
        getAge: [Function: getAge]
      }
```



## 函数功能新增



### 箭头函数

#### （1）没有this

函数体内的this对象，就是**定义时**所在的对象，而不是使用时所在的对象

**普通函数的 this 对象是执行是指定的，当然是可变的。箭头函数中 this 是固定的，是固定指向父级上下文 this。**

【eg1】

```js
var id = 'GLOBAL';
var obj = {
  	id: 'OBJ',
  	a: function(){
    	console.log(this.id);  //'OBJ'
  	},
  	b: () => {
    	console.log(this.id);  //'GLOBAL'
  	}
};
```

对象`obj`的方法`a`使用普通函数定义的，**普通函数作为对象的方法调用时，`this`指向它所属的对象**。所以，`this.id`就是`obj.id`，所以输出`'OBJ'`。 但是方法`b`是使用箭头函数定义的，箭头函数中的`this`实际是继承的它定义时所处的全局执行环境中的`this`，所以指向`Window`对象，所以输出`'GLOBAL'`。（**这里要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中！！**）

【eg2】

```js
var obj = {
        a:1, 
        print(){
            setTimeout(
               function(){console.log(this.a);},//普通函数
               1000
           );
        }
    };
obj.print();//undefined
//定时器中的函数由于没有默认宿主对象，setTimeout中的function未被任何对象调用，它的this指向默认是window对象，自然输出undefined。
-------------------------------------------
var obj = {
        a:1,
        print(){
            setTimeout(
               () => { console.log(this.a); },   //箭头函数
               1000
            );
        }
    };
    obj.print();// 1
//箭头函数的this指的是定义它的对象，所以this指向的是obj对象，所以obj.a确实应该输出1
```

#### （2）不可以改变this

⚠️最后注意，我们前文一直都强调箭头函数没有 this，所以呢，我们不可以用 call()、apply()、bind() 这些方法去改变this的指向。

#### （3）没有 arguments（可用rest参数代替）

箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象

什么是rest参数？**rest参数**，形式为：...变量名。**==arguments对象不是数组，只是可以下标访问而已，而rest参数是一个真正的数组。==**

```js
function f1(arr) {
    console.log(arguments);
}
f1([1,2,3]); // [1,2,3]
    
let f2 = (arr) => {
    console.log(arguments);
}
f2([1,3,9]); //Uncaught ReferenceError: arguments is not defined

let f3 = (...arr) => {   //rest参数是一个真正的数组
  	console.log(arr);
}
f3([1,4,5]); // [1,4,5]
```

#### （4）不能通过 new 关键字调用

+   JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。

+   当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。

+   当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。

+   箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。

+   ```
    var Foo = () => {};
    var foo = new Foo(); // TypeError: Foo is not a constructor
    ```

#### （5）没有原型

由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。

```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```

#### （6）没有 super

连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。

#### （7）不可以使用yield命令

因此箭头函数不能用作 Generator 函数。

#### （8）没有new.target

### new.target属性

`new`是从构造函数生成实例对象的命令。ES6 为`new`命令引入了一个`new.target`属性，该属性一般用在构造函数之中，返回`new`命令作用那个构造函数。如果构造函数不是通过**`new`命令或`Reflect.construct()`**调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是怎么调用的。

```js
function Person(name,age){
    console.log(name,age,new.target)
} 
var person=new Person('xm',10)              //xm 10 [Function: Person]   通过new调用
var person2=Person.apply(person,['xh',20])  //xh 20 undefined
var person3=Person.call(person2,'xh',20)    //xh 20 undefined
```

Class 内部调用`new.target`，返回当前 Class。需要注意的是，子类继承父类时，`new.target`会返回子类。

```js
class Person{
    constructor(name,age){
        this.name=name;
        this.age=age;
        console.log(name,age,new.target)
    }
}
var person4=new Person('xl',20)   //xl 20 [class Person]
```

更多用法可以参考：[es6.ruanyifeng.com/#docs/class…](https://link.juejin.cn/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fclass%23new-target-%E5%B1%9E%E6%80%A7)





## 对象简写

　ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。

```js
var name='高佳辉'
let getName=function(name){
    console.log(name)
}
var obj={name,getName}
console.log(obj)//{ name: '高佳辉', getName: [Function: getName] }
```

直接把名字等放进去，就可以形成一个对象，同名的



## 对象功能新增

常见的object方法

| 方法                        | 描述                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| create()                    | 创建一个对象，其原型为prototype，同时可添加多个属性。        |
| assign()                    | 把一个或多个源对象的可枚举、自有属性值复制到目标对象中，返回值为目标对象。 |
| defineProperty()            | 在一个对象上定义一个新属性或修改一个现有属性，并返回该对象。 |
| defineProperties()          | 在一个对象上定义一个或多个新属性或修改现有属性，并返回该对象。 |
| getOwnPropertyDescriptor()  | 获取目标对象上某自有属性的配置特性（属性描述符），返回值为配置对象。 |
| getOwnPropertyDescriptors() | 获取目标对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。 |
| getOwnPropertyNames()       | 获取目标对象上的全部自有属性名（包括不可枚举属性）组成的数组。 |
| getOwnPropertySymbols()     | 返回目标对象自身的所有 Symbol 属性的数组。                   |
| getPrototypeOf()            | 获取指定对象的原型，即目标对象的prototype属性的值。          |
| setPrototypeOf()            | 设置目标对象的原型为另一个对象或null，返回该目标对象。       |
| seal()                      | 密封对象，阻止其修改现有属性的配置特性，即将对象的所有属性的configurable特性设置为false（也就是全部属性都无法重新配置，唯独可以把writable的值由true改为false，即冻结属性），并阻止添加新属性，返回该对象。 |
| freeze()                    | 完全冻结对象，在seal的基础上，属性值也不可以修改，即每个属性的wirtable也被设为false。 |
| preventExtensions()         | 使某一对象不可扩展，也就是不能为其添加新属性。               |
| is()                        | 判断两个值是否是相同的值                                     |
| isSealed()                  | 用于判断目标对象是否被密封，返回布尔值。                     |
| isFrozen()                  | 用于判断目标对象是否被冻结，返回布尔值。                     |
| isExtensible()              | 用于判断一个对象是否可扩展，即是否可以添加新属性。           |
| keys()                      | 获取目标对象上所有可枚举属性组成的数组。                     |
| entries()                   | 返回目标对象可枚举属性的键值对的数组。                       |
| fromEntries()               | 把目标键值对列表转换为一个对象。                             |
| values(obj)                 | 返回目标对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 |



### 静态方法：20种

#### 对象Object的静态方法：13种（es5）

静态方法是直接通过Object.xx()来直接调用的方法，只要是继承了或者是原型链上有Object这个对象的内容都可以直接使用Object的静态方法。例如：Date对象、Array数组、Number、String…等这些都是可以直接使用Object.xx()之类的静态方法来返回内容。

1.  **Object.keys(arr)** ------返回一个数组。该数组的成员是该对象的键名。(只返回可枚举的属性)

    ------对象本身是没有长度的因此可以借助Object.keys(obj).length的方式来获取一个对象的属性个数

2.  **Object.getOwnPropertyNames() -**----- 返回一个数组。该数组的成员是该对象的键名。(返回可枚举和不可枚举的所有属性)

3.  **Object.getOwnPropertyDescriptor()** ------ 获取某个属性的描述对象。

4.  **Object.defineProperty(obj,prop,desc)** ------ 通过描述对象，定义某个属性。obj 需要定义属性的当前对象prop 当前需要定义的属性名 desc 属性描述符

5.  **Object.definePropertes()** ------ 通过描述对象，定义多个属性。

6.  **Object.preventExtensions()** ------ 防止对象扩展。

7.  **Object.isExtensible()** ------ 判断对象是否可扩展。

8.  **Object.seal()** ------ 禁止对象配置。

9.  **Object.isSealed()** ------ 判断一个对象是否可配置。

10.  **Object.freeze()** ------ 冻结一个对象。

11.  **Object.isFrozen()** ------ 判断一个对象是否被冻结。

12.  **Object.create()** ------ 该方法可以指定原型对象和属性，返回一个新的对象。

13.  **Object.getPrototypeOf()** ------ 获取对象的(Prototype)原型对象。

     ```js
     //获取一个对象的原型(prototype)
     var obj={}
     console.log(Object.getPrototypeOf(obj));
     console.log(Object.prototype);
     console.log(obj.__proto__);
     //[Object: null prototype] {}
     ```

#### 对象Object的静态方法：7种（es6）

1.  **Object.is()** ------ 比较两个值是否严格相等(与严格比较运算符（===）的行为基本一致,不同之处只有两个：**一是+0不等于-0，二是NaN等于自身**)

    ```js
    //两个值是否为同一个值。返回true或者false
    Object.is('foo', 'foo');  // true
    Object.is(null, null); // true
    Object.is([], []);  // false 引用数据类型的内存地址不同
    //特例
    console.log(+0 === -0);  //true
    console.log(Object.is(+0, -0));  //false
    console.log(NaN === NaN); //false
    console.log(Object.is(NaN, NaN));  //true
    ```

2.  **Object.assign(target,source…)** ------ 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）

    ```js
    //将另一个对象中可枚举的属性拷贝到原对象中
    var obj1 = {a:1,b:2}
    var obj2 = Object.assign({}, obj1);//深拷贝
    var obj3 = Object.assign(obj1, {});//浅拷贝
    var obj4 = {b:3,c:4}
    Object.assign(obj1,obj4);//{1,3,4} 重复后者会覆盖前者
    ```

3.  **Object.getOwnPropertyDescriptors()** ------ 返回指定对象所有自身属性（非继承属性）的描述对象

4.  **Object.setPrototypeOf()** ------ 用来设置一个对象的(Prototype)原型对象

    ```js
    //设置一个对象的原型
    function animal(){
         this.name = "animal"
    }
    animal.prototype.getname=function(){
          console.log(this.name);
    }
    var dog = new animal();
    var obj = {}
    Object.setPrototypeOf(obj,dog);
    obj.getname();//'animal'
    ```

5.  **Object.values()** ------ 返回一个数组。该数组的成员是该对象的键值。(只返回可枚举的属性)

6.  **Object.entries()** ------ 返回一个数组，该数组的成员是该对象的键值对数组。(只返回可枚举的属性)

7.  **Object.fromEntries()** ------ 是Object.entries()的逆操作，用于将一个键值对数组转为对象。



### 实例方法：6种

对象Object的实例方法：6种
实例方法是通过 new Object() 的形式创建出来的对象所能使用的方法，**本质是Object.prototype上面的方法**。因此其继承者(即其原型链上能找到Object的对象)也是可以使用的。

var obj = {};

1.  **obj.valueOf()** ------ 返回一个对象对应的值，默认情况下返回对象本身
2.  **obj.toString()** ------ 返回一个对象对应的字符串形式
3.  **obj.toLocaleString()** ------ 返回一个对象对应的本地字符串形式。
4.  **obj.hasOwnProperty()** ------ 判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
5.  **obj.isPrototypeOf()** ------ 判断当前对象是否为另一个对象的原型
6.  **obj.propertyIsEnumerable() -**----- 判断当前对象某个属性是否可枚举





## 数组功能新增

+   join()

+   push()和pop()

+   shift() 和 unshift()

+   sort()

+   reverse()

+   concat()

+   slice()

+   splice()

+   indexOf()和 lastIndexOf() （ES5新增）

+   forEach() （ES5新增）

+   map() （ES5新增）

+   filter() （ES5新增）

+   every() （ES5新增）

+   some() （ES5新增

    ------

    

>   +   Array.from() 方法将类似数组或可迭代对象转为数组
>   +   Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。
>   +   Array.prototype.find() 方法返获取元素(只会找一个)
>   +   Array.prototype.findIndex()** 方法找到一个元素在数组中的位置
>
>   ```
>   var arr2 = [1,2,3,4,5]
>   var res = arr2.find((v,k,arr)=>{
>       if(v>2)
>       return true
>   });
>   console.log(res);
>   ```
>
>   +   Array.prototype.includes()方法找到一个元素是否存在于数组中
>   +   Array.prototype.fill(v,start,end)** 方法填充数组
>   +   Array.prototype.keys()** 方法获取数组key
>   +   Array.prototype.values()方法获取数组元素
>   +   Array.prototype.entries()** 方法获取数组中的key、value键值对

**ES6: fill() 填充数组**

定义:  使用给定值，填充一个数组。

参数:

第一个元素(必须): 要填充数组的值

第二个元素(可选): 填充的开始位置,默认值为0

第三个元素(可选)：填充的结束位置，默认是为`this.length`

[MDN浏览器兼容](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Ffill%23%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7)

```
['a', 'b', 'c'].fill(7)
// [7, 7, 7]
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```



## 数组

##### ***Array.prototype.includes()***

此方法判断数组中是否存在某个值，如果存在返回 true，否则返回false。

```js
[1, 2, 3].includes(2); // true
[1, 2, 3].includes(4); // false
```

它还接受可选的第二个参数fromIndex：

```js
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true
```

不像indexOf，它采用严格相等比较。这意味着您可以检测数组是否包含NaN：

```js
[1, 2, NaN].includes(NaN); // true
```

也不同于indexOf，includes不会跳过缺失的索引：

```js
new Array(5).includes(undefined); // true
```

##### **array.find()**

find用于返回数组中满足条件的第一个元素的值，如果没有，返回undefined

```js
let numbers = [12, 5, 8, 130, 44];
let result = numbers.find(item => {
    return item > 8;
});
console.log(result);//12
//元素是对象
let items = [
    {id: 1, name: 'something'},
    {id: 2, name: 'anything'},
    {id: 3, name: 'nothing'},
];
let item = items.find(item => {
    return item.id == 3;
});
console.log(item) //Object { id: 3, name: "nothing" }
```





## 类

### class

class是一个语法糖，其底层还是通过 `构造函数` 去创建的。所以它的绝大部分功能，ES5 都可以做到。新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.sayName = function() {
    return this.name;
}

const xiaoming = new Person('小明', 18);
console.log(xiaoming);
```

上面代码用`ES6`的`class`实现，就是下面这样

```js
class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  
    //方法之间不需要逗号分隔，加了会报错
    sayName() {    //类的所有方法都定义在类的prototype属性上面，在类的实例上面调用方法，其实就是调用原型上的方法。
      return this.name;
    }
}
const xiaoming = new Person('小明', 18)
console.log(xiaoming);
// { name: '小明', age: 18 }

console.log((typeof Person));
// function
console.log(Person === Person.prototype.constructor);
// true
```

constructor方法，这就是构造方法，this关键字代表实例对象。 类的数据类型就是函数，类本身就指向构造函数。

>   ### *定义类的时候，前面不需要加 function, 而且方法之间不需要逗号分隔，加了会报错。

#### constructor 方法

constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this）

#### 类的实例

实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。

**注意：**

1.  class不存在变量提升

```js
new A(); // ReferenceError
class A {}
```

因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与继承有关，必须保证子类在父类之后定义。

```js
{
  let A = class {};
  class B extends A {}
}
```

### 静态方法

类相当于实例的原型，所有在类中定义的方法，都会被实例继承。 如果在一个方法前，加上 static 关键字，就表示==该方法不会被实例继承，而是直接通过类来调用，这就称为"静态方法"。==在静态方法中，`this`指向当前类。

```js
class A {
    static classMethod() {
      this.baz();//此处的this指向当前类，不是实例，所以调用的是类中的静态方法
    }
    static baz() {
      console.log('hello');
    }
    baz() {
      console.log('world');
    }
}
A.classMethod();//只可以通过类来调用
// hello

```

父类的静态方法，可以被子类继承。

```js
class A {
    static classMethod() {
        console.log('hello');
    }
}
class B extends A {}
B.classMethod() // 'hello'
```

### 静态属性

静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 写法是在实例属性的前面，加上static关键字。

```js
class MyClass {
  static myStaticProp = 42;

  constructor() {
    console.log(MyClass.myStaticProp); // 42
  }
}
```

### 继承

Class 可以通过extends关键字实现继承

```js
class Animal {}

class Cat extends Animal {
    constructor(name, age, color) {
        // 调用父类的constructor(name, age)
        super(name, age);
        this.color = color;
    }
    toString() {
        return this.color + ' ' + super.toString(); // 调用父类的toString()
    }
}
```

>   （1）constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象
>
>   （2）子类==必须在 constructor 方法中调用 super 方法==，否则新建实例就会报错 
>
>   ​	         子类自己的this对象，必须先通过 父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和           					 方法。如果不调用super方法，子类就得不到this对象
>
>   （3）如果子类没有定义constructor方法，这个方法会被默认添加
>
>   （4）es5 的构造函数在调用父构造函数前可以访问 this, 但 es6 的构造函数在调用父构造函数(即 super)前不能访问 this
>
>   ```js
>   class B extends A {
>    constructor(x, y, name) {
>      this.name = name; // ReferenceError
>      super(x, y);
>      this.name = name; // 正确
>    }
>   }
>   ```
>
>   (5) 父类的静态方法，也会被子类继承

### super

**super这个关键字，既可以当作函数使用，也可以当作对象使用**

#### super作为函数调用

super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。

```js
class A {}

class B extends A {
  constructor() {
    super();
  }
}
//super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)
```

#### super作为对象调用

**在普通方法中，指向父类的原型对象；** **在静态方法中，指向父类**。

##### super对象在普通函数中调用

```js
class A {
  constructor() {
    this.m = 6;
  }
  p() {
    return 2;
  }
}
A.prototype.x = 2;//

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2   super()指向
  }
    
   get m() {
     return super.p;//super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的(比如m),原型上就可呀访问（比如x)
  }
}

let b = new B()
b.m//undenfied
------------------------------------
上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()

```

##### super对象在静态方法中调用

用在静态方法之中，这时super将指向父类，而不是父类的原型对象

```js
class Parent {
  static myMethod(msg) {
    console.log('static', msg);
  }

  myMethod(msg) {
    console.log('instance', msg);
  }
}

class Child extends Parent {
  static myMethod(msg) {
    super.myMethod(msg);//静态方法中指向父类，调用父类的静态方法myMethod(msg)   (static msg)
  }

  myMethod(msg) {
    super.myMethod(msg);//普遍方法指向原型对象，调用方法                      （instance,msg)
  }
}

Child.myMethod(1); // static 1

const child = new Child();
child.myMethod(2); // instance 2
```

>   ### 总结
>
>   +   **class是一个语法糖，其底层还是通过 `构造函数` 去创建的。**
>
>   +   **类的所有方法都定义在类的prototype属性上面。**
>
>   +   **静态方法：在方法前加static，表示该方法不会被实例继承，而是直接通过类来调用。**
>
>   +   **静态属性：在属性前加static，指的是 Class 本身的属性，而不是定义在实例对象（this）上的属性。**
>
>   +   **es5 的构造函数在调用父构造函数前可以访问 this, 但 es6 的构造函数在调用父构造函数(即 super)前不能访问 this。**
>
>   +   **super**
>
>       +   **作为函数调用，代表父类的构造函数**
>       +   **作为对象调用，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。**
>
>       **class 作为构造函数的语法糖，同时有prototype属性和__proto_属性，因此同时存在两条继承链**
>
>       ​				**子类的__proto_属性，表示构造函数的继承，总是指向父类。**
>
>       ​				**子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。**

```js
class Animal{
    static num = 0;//静态属性
    constructor(name){
        this.name =name;//实例属性
        // //不推荐使用实例方法
        // this.getName = function(){//实例方法
        //     console.log(this.name);
        // }
        Animal.num++;//每新增一个动物，数量+1
    }
    getName(){//原型方法
        console.log(this.name);
    }
    static getNum(){//静态方法
        console.log(Animal.num);
    }
}
class Dog extends Animal{
    constructor(name,age,color){
        super(name);//方法
        this.age = age
        this.color = color
    }
    getColor(){
        super.getName();//对象指向父类的原型
        console.log(this.color);
    }
}
var dog1 = new Dog('xiaobai',3,'white');
console.log(dog1);
// dog1.getName();
dog1.getColor();
console.log(Dog.__proto__);//指向父类
//指向父类的原型
console.log(Dog.prototype.__proto__===Animal.prototype);
```









## Set集合

Set类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构展。Set的成员的不能通过索引的方式访问。

Set 构造函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。

**Set 这种数据结构中键名与键值相同**  详见迭代器

>   API：
>
>   Set.prototype.size			返回Set实例的元素总数
>
>   Set.prototype.add(value)		添加某个值，返回Set结构本身，不能添加重复的值
>
>   Set.prototype.delete(value)	删除某个值，返回一个布尔值，表示删除是否成功
>
>   Set.prototype.has(value)		返回一个布尔值，表示该值是否为Set的元素。
>
>   Set.prototype.clear()		Set.prototype.values()
>
>   Set.prototype.keys()		返回Set 对象中的元素值的一个 Iterator 对象。
>
>   Set.prototype.values()		返回Set 对象中的元素值的一个 Iterator 对象。
>
>   Set.prototype.entries()		返回Set 对象中的[key, value]的一个 Iterator 对象。
>
>   Set.prototype.forEach()		遍历
>
>   我们也经常使用Set进行数组去重的操作

```js
let arr = [1, 2, 3, 4, 5, 5, 5, 6, 4, 4, 5]
var s = new Set(arr); //可迭代对象
console.log(s) //Set(6) { 1, 2, 3, 4, 5, 6 }            //得到的是set对象
let arr1 = Array.from(s); //数组                          //转化为数组
console.log(arr1) //[ 1, 2, 3, 4, 5, 6 ]
console.log(s.size) //6
s.add(8)
console.log(s) //Set(7) { 1, 2, 3, 4, 5, 6, 8 }
s.delete(1)
console.log(s) //Set(6) { 2, 3, 4, 5, 6, 8 }
console.log(s.has(2)) //true
console.log(s.entries()) //set集合中的键和值是一致的
    // 运行结果:[ 5, 5 ],
    // [ 6, 6 ],
    // [ 8, 8 ]
```



## Map集合（对象）

### 简介

Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。Map类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，==Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，==是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。Map 可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。[[key,value],[key,value]]

**键名的等价性判断是通过调用Object.is()方法实现的**，所以数字5与字符串"5"会被判定为两种类型，可以分别作为独立的两个键出现在程序中，**==这一点与对象不一样，因为对象的属性名总会被强制转换成字符串类型==**

注意：有一个例外，**Map集合中将+0和-0视为相等，与Object.is()结果不同**

>   简单来说，就是在Map中任何的类型的数据都可以为键，值跟Object一致。
>
>   *   我们在使用{}时，有可能会出现属性名和原型中的属性名一致的情况，Map不会
>   *   一个 Map的键可以是任意值，包括函数、对象或任意基本类型。
>   *   Map 中的 key 是有序的。{}无序
>   *   Map 的键值对个数可以轻易地通过size 属性获取，{}需要计算

### 1.创建map集合

如果要向Map集合中添加新的元素，可以调用set()方法并分别传入键名和对应值作为两个参数；如果要从集合中获取信息，可以调用get()方法

```js
let map = new Map();
map.set("title", "Understanding ES6");
map.set("year", 2017);
console.log(map.get("title")); // "Understanding ES6"
console.log(map.get("year")); // 2017
```

在这个示例中，两组键值对分别被存入了集合Map中，键名"title"对应的值是一个字符串，键名"year"对应的值是一个数字。

调用get()方法可以获得两个键名对应的值。**如果调用get()方法时传入的键名在Map集合中不存在，则会返回undefined **   在对象中，无法用对象作为对象属性的键名。但是在Map集合中，却可以这样做



### 2、Map集合支持的方法

　　在设计语言新标准时，委员会为Map集合与Set集合设计了如下3个通用的方法

　　（1）has(key)检测指定的键名在Map集合中是否已经存在

　　（2）delete(key)从Map集合中移除指定键名及其对应的值

　　（3）clear()移除Map集合中的所有键值对

　　Map集合同样支持size属性，其代表当前集合中包含的键值对数量

>   API：
>
>   *   Map.prototype.size				返回Map对象的键/值对的数量。
>   *   Map.prototype.set(key, value)		set方法设置键名key对应的键值为value
>   *   Map.prototype.get(key)			get方法读取key对应的键值
>   *   Map.prototype.has(key)			某个键是否在当前 Map 对象之中
>   *   Map.prototype.delete(key)		delete方法删除某个键，返回true
>   *   Map.prototype.clear()			清除所有成员
>   *   Map.prototype.keys() 			返回键名的遍历器
>   *   Map.prototype.values()			返回键值的遍历器
>   *   Map.prototype.entries()			返回键值对的遍历器
>   *   Map.prototype.forEach()			遍历

```js
let map = new Map();
    map.set("name", "huochai");
    map.set("age", 25);
console.log(map.size); // 2
console.log(map.has("name")); // true
console.log(map.get("name")); // "huochai"
console.log(map.has("age")); // true
console.log(map.get("age")); // 25
	map.delete("name");
console.log(map.has("name")); // false
console.log(map.get("name")); // undefined
console.log(map.size); // 1
	map.clear();
console.log(map.has("name")); // false
console.log(map.get("name")); // undefined
console.log(map.has("age")); // false
console.log(map.get("age")); // undefined
console.log(map.size); // 0
```

### 3、传入数组来初始化Map集合

可以向Map构造函数传入数组来初始化一个Map集合，这一点同样与Set集合相似。数组中的每个元素都是一个子数组，子数组中包含一个键值对的键名与值两个元素。因此，==整个Map集合中包含的全是这样的两元素数组==

```js
//Map集合在创建时，也可以传递一个数组进行创建，但是需要注意形似为[key,value]
传入数组来初始化Map集合
	可以向Map构造函数传入数组来初始化一个Map集合，这一点同样与Set集合相似。数组中的每个元素都是一个子数组，子数组中包含一个键值对的键名与值两个元素。因此，整个Map集合中包含的全是这样的两元素数组

let map = new Map([["name", "huochai"], ["age", 25]]);
console.log(map.has("name")); // true
console.log(map.get("name")); // "huochai"
console.log(map.has("age")); // true
console.log(map.get("age")); // 25
console.log(map.size); // 2

//初始化构造函数之后，键名"name"和"age"分别被添加到Map集合中。数组包裹数组的模式看起来可能有点儿奇怪，但由于Map集合可以接受任意数据类型的键名，为了确保它们在被存储到Map集合中之前不会被强制转换为其他数据类型，因而只能将它们放在数组中，因为这是唯一一种可以准确地呈现键名类型的方式
```

### 4、同名属性碰撞

**Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键**。这就解决了同名属性碰撞（clash）的问题，**扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名**

```
const map = new Map();
map.set(['a'], 555);
map.get(['a']) // undefined
```

　　上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`

### 5、遍历

Map结构原生提供三个遍历器生成函数和一个遍历方法

```js
keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回所有成员的遍历器
forEach()：遍历 Map 的所有成员
```

注意：**Map的遍历顺序就是插入顺序**

```js
const map = new Map([
  ['F', 'no'],
  ['T',  'yes'],
]);

for (let key of map.keys()) {
  console.log(key);
}
// "F"
// "T"

for (let value of map.values()) {
  console.log(value);
}
// "no"
// "yes"

for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
// "F" "no"
// "T" "yes"

// 或者
for (let [key, value] of map.entries()) {
  console.log(key, value);
}
// "F" "no"
// "T" "yes"

// 等同于使用map.entries()
for (let [key, value] of map) {
  console.log(key, value);
}
// "F" "no"
// "T" "yes"
```

上面代码最后的那个例子，表示Map结构的默认遍历器接口，就是`entries`方法

```js
map[Symbol.iterator] === map.entries// true
```

### 6、转为数组

　　Map结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）

```js
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
```

结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤

```js
const map0 = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');

const map1 = new Map(
  [...map0].filter(([k, v]) => k < 3)
);
// 产生 Map 结构 {1 => 'a', 2 => 'b'}

const map2 = new Map(
  [...map0].map(([k, v]) => [k * 2, '_' + v])
    );
// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
```

### 7、forEach()

　Map还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历

```js
const map = new Map([[1, 'one'],[2, 'two'],[3, 'three']]);
map.forEach((value,key,map)=>{
    //one 1 {1 => "one", 2 => "two", 3 => "three"}
    //two 2 {1 => "one", 2 => "two", 3 => "three"}
    //three 3 {1 => "one", 2 => "two", 3 => "three"}
    console.log(value,key,map);
})
```

注意：遍历过程中，Map会按照键值对插入Map集合的顺序将相应信息传入forEach()方法的回调函数；而在数组中，会按照数值型索引值的顺序依次传入回调函数

　　`forEach`方法还可以接受第二个参数，用来绑定`this`

```js
const reporter = {
  report: function(key, value) {
    console.log("Key: %s, Value: %s", key, value);
  }
};

map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);
```

上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`



## 模板字符串

```js
let name='小明';
let score=83;
let result=`${name}${score>60?'的考试成绩及格':'的考试成绩不及格'}`
console.log(result)
```



## Symbol

ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。

### 基本用法

Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。

```js
let sy = Symbol("KK");
console.log(sy);   // Symbol(KK)
typeof(sy);        // "symbol"
 
// 相同参数 Symbol() 返回的值不相等
let sy1 = Symbol("kk"); 
sy === sy1;       // false
```

### 使用场景

#### 作为属性名

**用法**

由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。

```js
let myname=Symbol('name');
// 写法一
let obj={};
obj[myname]='高佳辉';
console.log(obj)//{ [Symbol(name)]: '高佳辉' }
console.log(obj[myname])//高佳辉
-------------------------
// 写法二
let obj={
    [myname]:'高佳辉'
}
console.log(obj)
-------------------------
// 写法三
let obj={}
Object.defineProperty(obj,myname,{value:'高佳辉'})
```

注意Symbol 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性。

```
let syObject = {};
syObject[sy] = "kk";
 
syObject[sy];  // "kk"
syObject.sy;   // undefined
```



#### 定义常量

```js
const COLOR_RED = Symbol("red");
const COLOR_YELLOW = Symbol("yellow");
const COLOR_BLUE = Symbol("blue");
```

####  消除魔术字符串

```js
var obj = {
        n1:Symbol('小红'),
        n2:Symbol('小明')
    }
    function getres(name){
        if(name == obj.n1)
            console.log('哭了');
        else if(name==obj.n2){
            console.log('天气很好')
        }
    }
    getres(obj.n1);
    getres(obj.n2);
```



### 方法

Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for...in 、 for...of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。

#### Object.getOwnPropertySymbols() 

该方法返回一个数组，只包含symbol类型

####  Reflect.ownKeys()

返回所有的键数组

```js
let syObject = {};
syObject[sy] = "kk";
console.log(syObject);
 
for (let i in syObject) {
  console.log(i);
}    // 无输出
 
Object.keys(syObject);                     // []
Object.getOwnPropertySymbols(syObject);    // [Symbol(key1)]
Reflect.ownKeys(syObject);                 // [Symbol(key1)]
```

#### Symbol.for()

Symbol.for() 类似单例模式，首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索。

```js
let yellow = Symbol("Yellow");
let yellow1 = Symbol.for("Yellow");
yellow === yellow1;      // false
 
let yellow2 = Symbol.for("Yellow");
yellow1 === yellow2;     // true
```

#### Symbol.keyFor()

Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。

```js
let yellow1 = Symbol.for("Yellow"); 
Symbol.keyFor(yellow1);    // "Yellow"
```



## 迭代器

所谓迭代器，其实就是一个具有 **next() 方法**的对象，每次调用 next() 都会返回一个结果对象，该结果对象有两个属性，value 表示当前的值，done 表示遍历是否结束。

>   遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。
>
>   return 方法的使用场合是，如果 for...of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。

### 自定义一个迭代器

```js
function createIterator(items){
    var i=0;
    return{
        next:function(){
            var done=(i>=items.length);
            var value=!done ? items[i++] :undefined;

            return{
                done:done,
                value:value
            };
        }
    };
}
//iterator就是一个迭代器对象
var iterator=createIterator([1,2,3]);

console.log(iterator.next()); // { done: false, value: 1 }
console.log(iterator.next()); // { done: false, value: 2 }
console.log(iterator.next()); // { done: false, value: 3 }
console.log(iterator.next()); // { done: true, value: undefined }
```



### 内建迭代器

为了更好的访问对象中的内容，比如有的时候我们仅需要数组中的值，但有的时候不仅需要使用值还需要使用索引，ES6 为数组、Map、Set 集合内建了以下三种迭代器：

1.  entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值。
2.  keys() 返回一个遍历器对象，用来遍历所有的键名。
3.  values() 返回一个遍历器对象，用来遍历所有的键值。

```js
var colors = ["red", "green", "blue"];

for (let index of colors.keys()) {
    console.log(index);
}

// 0
// 1
// 2

for (let color of colors.values()) {
    console.log(color);
}

// red
// green
// blue

for (let item of colors.entries()) {
    console.log(item);
}

// [ 0, "red" ]
// [ 1, "green" ]
// [ 2, "blue" ]

```

Map 类型与数组类似，但是对于 Set 类型需要注意以下：

```js
var colors = new Set(["red", "green", "blue"]);

for (let index of colors.keys()) {
    console.log(index);
}

// red
// green
// blue

for (let color of colors.values()) {
    console.log(color);
}

// red
// green
// blue

for (let item of colors.entries()) {
    console.log(item);
}

// [ "red", "red" ]
// [ "green", "green" ]
// [ "blue", "blue" ]
```

Set 类型的 keys() 和 values() 返回的是相同的迭代器，这也意味着在 Set 这种数据结构中键名与键值相同。

而且每个集合类型都有一个默认的迭代器，在 for-of 循环中，如果没有显式指定则使用默认的迭代器。**数组和 Set 集合的默认迭代器是 values() 方法，Map 集合的默认迭代器是 entries() 方法。**（输出键值对）





### 可遍历

其实一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。

ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是"可遍历的"（iterable）。

### for of（不能遍历对象）

特性：

1.  （可遍历map，object,array,set string等）用来遍历数据，比如组中的值

2.  避免了for in的所有缺点，可以使用break,continue和return，不仅支持数组的遍历，还可以遍历类似数组的对象。

    我们直接 for of 遍历一个对象，会报错，然而如果我们给该对象添加 Symbol.iterator 属性：

    ```
    const obj = {
        value: 1
    };
    
    obj[Symbol.iterator] = function() {
        return createIterator([1, 2, 3]);
    };
    
    for (value of obj) {
        console.log(value);
    }
    
    // 1
    // 2
    // 3
    复制代码
    ```

    由此，我们也可以发现 **for of 遍历的其实是对象的 Symbol.iterator 属性。**

>   所以 for...of 循环可以使用的范围包括：
>
>   1.  **数组**
>   2.  **Set**
>   3.  **Map**
>   4.  **类数组对象，如 arguments 对象、DOM NodeList 对象**
>   5.  **Generator 对象**
>   6.  **字符串**

### 默认可遍历对象

尽管我们没有手动添加 Symbol.iterator 属性，还是可以遍历成功（数组），这是因为 ES6 默认部署了 Symbol.iterator 属性，当然我们也可以手动修改这个属性

```js
var colors = ["red", "green", "blue"];

colors[Symbol.iterator] = function() {
    return createIterator([1, 2, 3]);
};

for (let color of colors) {
    console.log(color);
}

// 1
// 2
// 3
```





## 生成器

>   生成器是一种返回迭代器的函数。 通过 `function` 关键字后面 加 `*` 来定义，使用 `yield` 关键字返回迭代器
>
>   不能用箭头函数来生成迭代器



## proxy/reflect

proxy我们可以理解为代理，其含义是在对象操作时，我们可以做一些额外的操作；例如对数据的处理，对构造函数的处理，对数据的验证。

代理就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由我们自己来定义。例如对数据的处理，对构造函数的处理，对数据的验证等等。

`Proxy`语法：

```js
const proxy = new Proxy(target, handler)
```

`new Proxy()`可以传入两个参数：

+   `target`: 目标对象（可以是任何类型的对象，包括原生数组，函数，也可以是另一个代理）
+   `handler`: 处理程序对象（定义了一个或多个函数的对象）。

```js
let target={
    name:'小明',
    age:15
}

let handler={
    get:(target,name)=>{
        return target[name]+'笑了';
    },
}

let pro=new Proxy(target,handler);
console.log(pro.name)//小明笑了
---------------------------------------------
    let obj = {
     name:"小明",
     age:15
}

//旧写法
console.log(name in obj);
//结果为 true
    
//Reflect对象操作
console.log(Reflect.has(obj,"name"));
//结果为 true
```

具体可参考：[proxy/reflext](https://juejin.cn/post/6953877508919918599#heading-0)

https://www.jianshu.com/p/9e07f182859b



## 请求

### Promise

Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

Promise对象代表一个异步操作有三种状态： ==**pending（进行中）**、**fulfilled（已成功）**和**rejected（已失败）**。==

状态发生改变之后就凝固了，不会再变了，会一直保持这个结果，这时就称为 **==resolved（已定型==）**。

一个 Promise 就是一个代表了 `异步操作`最终`完成或者失败的对象`。promise本质上是一个`绑定了回调的对象`

```js
//预测三秒会下雨
var pm1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        if(Math.random()>0.1){
            resolve('下雨了1')
        }else{
            reject('没下')
        }
    },3000)
});
//可以在任意的时候去处理结果
// pm.then((res)=>{
//     console.log(res);
// }).catch((err)=>{
//     console.log(err);
// }).finally(()=>{//无论是够成功与否，都会执行
//     console.log('测试了一次');
// })
```

#### 原型方法：

| Promise.prototype.then()        | 当状态由pending变为fulfilled的时候执行该回调函数             |
| ------------------------------- | ------------------------------------------------------------ |
| **Promise.prototype.catch()**   | **当状态由pending变为rejected的时候执行该回调函数**          |
| **Promise.prototype.finally()** | **在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数** |

#### 其他方法:

1.  **Promise.all([p1,p2])**				当p1,p2状态都为fulfilled时候，该实例的状态才为fulfilled

    ```js
    //需要多个承诺都成功，才执行成功的回调   并发
    // Promise.all([pm1,pm2]).then((res)=>{
    //     console.log(res);//如果都成功了，返回每个承诺成功的结果的数组
    // })
    ```

    

2.  **Promise.any([p1,p2])**			只要p1,p2状态有一个变为fulfilled，该实例的状态为fulfilled

    ```
    //多个承诺只要有一个成功，就执行成功的回调
    ```

    

3.  **Promise.race([p1,p2])**			当p1，p2之中有一个实例率先改变状态，该实例的状态就跟着改变

    ```js
    //哪一个承诺先执行，就返回那一个承诺的结果
    // Promise.race([pm1,pm2]).then((res)=>{
    //     console.log(res);//如果成功，打印成功承诺的结果
    // })
    ```

    

4.  **Promise.allSettled()**				ES11新增，所有的承诺都执行完毕后，返回结果数组

    ```
    // 将所有状态改变后的承诺结果组成数返回
    // Promise.allSettled([pm1,pm2]).then((res)=>{
    //         console.log(res);
    // })
    ```

    

5.  **Promise.resolve()**				用于将现有对象转化为Promise实例fulfilled状态

    ```js
    var res = Promise.resolve('data')//promise对象
    res.then((res)=>{
        console.log(res);
    })
    ```

    

6.  **Promise.reject()**				用于将现有对象转化为Promise实例rejected状态

    ```js
    var err = Promise.reject(new Error('出错了！'));
    err.catch((err)=>{
        console.log(err);
    })
    ```

    

### Generator

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

特点

*    function关键字与函数名之间有个星号
*    函数内部使用yield表达式
*   可以放置return语句，返回最终的结果

```js
function* getData(){
     yield f1();
     yield f2();
     yield f3();
}
var res = getData();
res.next()
```

#### 作用：

##### 交替执行

```js
function* getData(){
    while(true){  
        yield console.log('11');
        yield console.log('22');
    }
}
var res = getData();
setInterval(() => {
    res.next()
},1000);
```

##### 顺序执行

与promise结合实现对异步代码的顺序控制

```js
function f1(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            if(Math.random()>0.1){
                resolve('下雨了2')
            }else{
                reject('没下')
            }
        },1000)
    })
}
function* getData(){
    yield f1();
}
var res = getData();
// res.next().value.then((res)=>{
//     console.log(res);
// });//{value:pomise,done:false}
```

### Async

Async函数是generator函数的语法糖，在generator函数的基础上添加了一些更加方便用户操作的新特性。Async函数的执行和普通函数一致，只需要一行代码即可，因为他具有内置的执行。async与await对比*与yield有更好的语义。

特点：

*   await关键字只在async函数内有效。
*   async函数返回一个 Promise 对象。
*   async函数可以实现也是一种异步函数同步化的实现

>   #### 传统ajax异步处理：
>
>   ```js
>       //传统处理ajax异步处理方式,我们是将
>       $.ajax({
>           method : 'POST',
>           data : {},
>           success : function(){
>               $.ajax({
>                   method : '',
>                   data : {},
>                   success  : function(){
>                       $.ajax()
>                   }
>               })
>               ......
>           }
>       })
>   ```
>
>   ```js
>       function ajax(){
>           return new Promise(function(resolve,reject){
>               $.ajax({
>                   method : 'POST',
>                   data : {},
>                   success : function(res){
>                       resolve(res)
>                   }
>               })
>           })
>       }
>        // 在每次ajax请求完成后，我们return了一个我们封装的ajax(),而这个ajax()return 了一个promise对象实例，我们通过then()方法,来捕捉这个异步的成功状态resolve。catch()方法reject
>       ajax().then(function(res){
>           if(res.data.code == 200){}
>           ..
>           return ajax()
>       }).then(function(res){
>           if(res.data.code == 200){}
>           ........
>           return ajax()
>       }).then(function(){
>           .....
>       }).catch(function(){})
>   
>   ```
>
>   ------



```js
const pro1 = (url) => {
            return new Promise((resolve, reject) => {
                let xml = new XMLHttpRequest;
                xml.open('GET', url, true);
                //一定是先open  再设置请求头  再send
                xml.setRequestHeader("Authorization", "token")
                xml.send(null)
                xml.onreadystatechange = function() {
                    if (xml.readyState == 4 && xml.status == 200) {
                        resolve(xml)//成功回调
                    } else if (xml.status != 200) {
                        reject(new Error('错误'))//失败回调
                    }
                }
            })
    
const url1 = "http://47.101.137.125:8002/carousel/findAll";
const url2 = "http://47.101.137.125:8002/index/category/findAll";

```

#### 1.Promise.all([])实现并发

```
//Promise.all([])实现并发
const get = () => {
            Promise.all([pro1(url1), pro1(url2)]).then((res) => {
                console.log(res)
            })
        }
```

![image-20211114211833921](https://gitee.com/gao-jiahuina/blogimgs/raw/master/img/20211114211833.png)

#### 2.async函数实现

```js
const get = async() => {
            const res1 = await pro1(url1);
            const res2 = await pro1(url2);
            console.log("res1", JSON.parse(res1.responseText))
            console.log("res2", JSON.parse(res2.responseText))
        }
```

![](https://gitee.com/gao-jiahuina/blogimgs/raw/master/img/20211114212013.png)

### 组合实例

```html
<body>
    <button id="btn">按钮</button>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.js"></script>
    <script>

        const url1 = "http://47.101.137.125:8002/carousel/findAll";
        const url2 = "http://47.101.137.125:8002/index/category/findAll";

        //promise实例
        const pro1 = (url) => {
            return new Promise((resolve, reject) => {
                let xml = new XMLHttpRequest;
                xml.open('GET', url, true);
                //一定是先open  再设置请求头  再send
                xml.setRequestHeader("Authorization", "token")
                xml.send(null)
                xml.onreadystatechange = function() {
                    if (xml.readyState == 4 && xml.status == 200) {
                        resolve(xml)
                    } else if (xml.status != 200) {
                        reject(new Error('错误'))
                    }
                }
            })
        }

        // 1.原生promise调用，会有回调地狱
        function get() {
            pro1(url1).then((res) => {
                console.log('url1', res)
                setTimeout(() => {
                    pro1(url2).then((res) => {
                        console.log('url2', res)
                    })
                }, 1000)

            }).catch(() => {
                let err = new Error('请求失败')
                console.warn(err)
            })
        }
        
        
        //2. async函数实现请求
        const get = async() => {
            const res1 = await pro1(url1);
            const res2 = await pro1(url2);
            console.log("res1", JSON.parse(res1.responseText))
            console.log("res2", JSON.parse(res2.responseText))
        }

        // 3.Promise.all()实现并发请求
        const get = () => {
            Promise.allSettled([pro1(url1), pro1(url2)]).then((res) => {
                console.log(res)
            })
        }


        // 4.generatir函数
        function* gener() {
            yield pro1(url1);
            yield pro1(url2);
        }
        let res = gener();
        var get = () => {
            res.next().value.then((res) => {
                console.log(res)
            })
        }

        // 事件
        $('#btn').on('click', function() {
            get()
        })
    </script>
</body>
```



## Babel

==参考：==https://www.jiangruitao.com/babel/

Babel是一个广泛使用的ES6转换器，使用babel可以将ES6代码转为ES5代码，从而在老版本的浏览器执行。这意味着，可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。

### 入门：

在本地新建一个文件夹babel01，在该文件夹下新建一个js文件，文件命名为babel.config.js。该文件是 Babel配置文件 ，我们在该文件里输入如下内容：

```js
module.exports = {
    presets: ["@babel/env"],
    plugins: []
  }
```

然后在该文件夹下新建一个js文件main.js，该js里的代码是我们需要转译的，我们写入代码

```js
var fn = (num) => num + 2;
```

然后执行下面的命令安装三个npm包，这些npm包是Babel官方包

```js
// npm一次性安装多个包，包名之间用空格隔开
  npm install --save-dev @babel/cli @babel/core @babel/preset-env
```

安装完成后，执行下面的命令进行转码，该命令含义是把main.js转码生成compiled.js文件

```js
npx babel main.js -o compiled.js
```

此时文件夹下会生成compiled.js，该文件是转换后的代码：

```js
"use strict";
  var fn = function fn(num) {
    return num + 2;
  }
```

![image-20211115184145677](https://gitee.com/gao-jiahuina/blogimgs/raw/master/img/20211115184145.png)



### 关于垫片(babel-polyfill)

Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。

举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用core-js和regenerator-runtime(后者提供generator函数的转码)，为当前环境提供一个垫片。

```js
//a.js
import "core-js/stable";
import "regenerator-runtime/runtime";

var promise = Promise.resolve('ok');
console.log(promise);
```

安装两个npm包core-js和regenerator-runtime

```
  npm install --save core-js regenerator-runtime
```

我们使用webpack来讲述这个过程,首先进行webpack和其命令行工具的安装

```
 npm install webpack webpack-cli --save-dev
```

```js
"scripts": {
        "dev": "npx webpack a.js -o b.js"
    },
```

```js
npm run dev //即可
```

参考：https://www.jiangruitao.com/babel/

## 模块化

![img](https://gitee.com/gao-jiahuina/blogimgs/raw/master/img/20211115145134.webp)

每个模块内部，都有一个module对象，代表当前模块。 

| id       | 模块的识别符，通常是带有绝对路径的模块文件名。 |
| -------- | ---------------------------------------------- |
| filename | 模块的文件名，带有绝对路径。                   |
| loaded   | 返回一个布尔值，表示模块是否已经完成加载。     |
| parent   | 返回一个对象，表示调用该模块的模块。           |
| children | 返回一个数组，表示该模块要用到的其他模块。     |
| exports  | 表示模块对外输出的值。                         |

<img src="https://gitee.com/gao-jiahuina/blogimgs/raw/master/img/20211115153618.png" alt="image-20211115153618919" style="zoom:67%;" />

### 一、模块化开发

#### **1.模块化开发**

将一些特定功能的方法组合实现一个模块。

>   维护性较高：当你引入很多个JS文件的时候，很有可能会不清楚这些JS文件之间的依赖关系，从而导致加载顺序出错。使用模块化开发之后就能避免这个问题。
>
>   相互独立：JS本身是没有命名空间的，为了减少命名冲突，经常使用对象或者闭包来减少命名冲突。对象只能减少命名冲突的概率，闭包的过多使用会造成内存泄漏。模块化开发之后，在模块内任何形式的命名都不会和其他模块的命名产生冲突，有效的解决了命名冲突的问题。
>
>   代码复用：当我们想要实现某个功能的时候，如果某个模块正好有这个功能，我们就可以直接引用该模块，不必再写多余的代码，这样可以提高代码整体的效率，减少重复冗余的代码。

#### 2.node对模块化的支持

*   node实现了CommonJS模块化

*   *   node可以支持CommonJS模块化的语法 
    *   浏览器不支持CommonJS的语法

*   node v13.2.0之前(ES6)

    在package.json中配置：

    ```js
    {   
    "type": "module",   
        "scripts": {     
            "start": "node --experimental-modules index.js"   
        }
    }
    ```

    node v13.2.0之后

    *   只需要在package.json中配置：

    *   ```js
        {
        "type": "module"
        }
        ```

    *   

### 二、CommonJS(4个)

Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module`、`exports`、`require`、`global`。实际使用时，用`module.exports`定义当前模块对外输出的接口（不推荐直接用`exports`），用`require`加载模块。

CommonJS规定，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。==每个模块内部，module变量代表当前模块。这个变量是一个对象==，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。

```js
// 定义模块math.js
var basicNum = 0;
function add(a, b) {
  return a + b;
}
module.exports = { //在这里写上需要向外暴露的函数、变量
  add: add,
  basicNum: basicNum
}

// 引用自定义的模块时，参数包含路径，可省略.js
var math = require('./math');
math.add(2, 5);

// 引用核心模块时，不需要带路径
var http = require('http');
http.createService(...).listen(3000);
```

### 三、 AMD和require.js

*   采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行。require.js 实现了 AMD 规范。
*   对浏览器端的异步加载尤其适用,是一个浏览器端模块化开发的规范。

AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用`require.config()`指定引用路径等，用`define()`定义模块，用`require()`加载模块。

首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置`require.config()`并规定项目中用到的基础模块。

```js
/** 网页中引入require.js及main.js **/
<script src="js/require.js" data-main="js/main"></script>

/** main.js 入口文件/主模块 **/
// 首先用config()指定各模块路径和引用名
require.config({
  baseUrl: "js/lib",
  paths: {
    "jquery": "jquery.min",  //实际路径为js/lib/jquery.min.js
    "underscore": "underscore.min",
  }
});
// 执行基本操作
require(["jquery","underscore"],function($,_){
  // some code here
});
```

引用模块的时候，我们将模块名放在`[]`中作为`reqiure()`的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在`[]`中作为`define()`的第一参数。

```js
// 定义math.js模块
define(function () {
    var basicNum = 0;
    var add = function (x, y) {
        return x + y;
    };
    return {
        add: add,
        basicNum :basicNum
    };
});
// 定义一个依赖underscore.js的模块
define(['underscore'],function(_){
  var classify = function(list){
    _.countBy(list,function(num){
      return num > 30 ? 'old' : 'young';
    })
  };
  return {
    classify :classify
  };
})

// 引用模块，将模块放在[]内
require(['jquery', 'math'],function($, math){
  var sum = math.add(10,20);
  $("#sum").html(sum);
});
```

### 四、CMD和sea.js

CMD是另一种js模块化方案，它与AMD很类似，不同点在于：==AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行==。此规范其实是在sea.js推广过程中产生的。

>   区别：
>
>   AMD是依赖前置，在定义模块的时候就要声明其依赖的模块。
>
>   换句话说，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块。
>
>   代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大
>
>   CMD是就近依赖，只有在用到某个模块的时候再去require
>
>   代码在运行时，首先是不知道依赖的，需要遍历所有的require关键字，找出后面的依赖。具体做法是将function toString后，用正则匹配出require关键字后面的依赖。显然，这是一种牺牲性能来换取更多开发便利的方法。

### 五、ES6 Module（2个）

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

```js
/** 定义模块 math.js **/
var basicNum = 0;
var add = function (a, b) {
    return a + b;
};
export { basicNum, add };

/** 引用模块 **/
import { basicNum, add } from './math';
function test(ele) {
    ele.textContent = add(99 + basicNum);
}
```

如上例所示，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了`export default`命令，为模块指定默认输出，对应的`import`语句不需要使用大括号。这也更趋近于ADM的引用写法。

```js
/** export default **/
//定义输出
export default { basicNum, add };
//引入
import math from './math';
function test(ele) {
    ele.textContent = math.add(99 + math.basicNum);
}
```

ES6的模块不是对象，`import`命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。

### 六、 ES6 模块与 CommonJS 模块的差异

#### 1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

*   CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
*   ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个==只读引用==。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是==动态引用==，并且不会缓存值，模块里面的变量绑定其所在的模块。

#### 2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

*   运行时加载: CommonJS 模块就是对象；即在输入时是==先加载整个模块，生成一个对象==，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
*   编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以==指定加载某个输出值==，而不是加载整个模块，这种加载称为“编译时加载”。即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。

CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

#### **CommonJS的模块化：**

```js
// CommonJS模块 
 let { stat, exists, readfile } = require('fs');
 // 等同于如下代码块
 let _fs = require('fs'); //首先JS会先创建一个对象，获取fs中所有的属性和方法。ES6模块不做这个事（静态加载）。
 let stat = _fs.stat;
 let exists = _fs.exists; 
 let readfile = _fs.readfile; 
------------------------------------------------------------
//模块导出（a.js）
module.exports = {
  firstName: 'Michael',
  lastName: 'vicky'
};
//模块导入(b.js)
const { firstName, lastName } = require('./testExports');
console.log(firstName, lastName);
```

#### ES6模块化

```js
//1.在script标签中使用
<script type="module">
//模块的导入及使用
</script>  
//2.文件引入的方式
<script type="module" src="index.js"></script><!-- 入口文件 -->  
```

### 七、模块导入和导出

*   分别导出

*   统一导出

*   默认导出（export default）

    

*   通用导入

*   关于别名

*   解构导入

*   默认导入（export default）



## 柯里化

只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术

### Currying有哪些好处？

主要有3个作用： **参数复用**、**提前返回**和 **延迟执行**提前返回 和 延迟执行 也很好理解，因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。

实例：例如我们在使用ajax的时候url是不变的，但是传递的参数不同将返回不同的数据，那么我们就可以把url封装到一个函数里然后返回一个带参数的函数，通过返回的函数去处理不同参数的情况

```js
function requestCurry(url){
    return function(params){
        return new Promise((resolve,reject)=>{
            axios({
                method:"get",
                url:url,
                data:{
                    ...params
                }
            }).then(res=>{
                resolve(res)
            }).catch(err=>{
                reject(err)
            })
        })
    }
}

const userRequest = requestCurry("http://47.101.137.125:8003/baseUser/findUserDetailsById")

//请求参数id为25
userRequest({
    id:25
}).then(res=>{
    //请求成功
    console.log(res)
})
//请求参数id为26
userRequest({
    id:26
}).then(res=>{
    //请求成功
    console.log(res)
})
```





## ES8

### padStart() 补充指定位数

padStart()：用另一个字符串填充当前字符串，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。

```js
const str1 = '5' console.log(str1.padStart(4, '0'))  //  "0005"
```

padEnd()：用一个字符串填充当前字符串，返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。

```js
const str1 = '5' console.log(str1.padEnd(4, '0'))  //  "5000"
```

上面代码中，`padStart()`和`padStart()`一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。

如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。

```
 'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'
```



函数尾部可以有(,)

```js
function f1(a,b,){
    console.log(a,b);
}
f1(1,2,);
```

## ES9

### for await…of

创建一个循环，该循环遍历异步可迭代对象以及同步可迭代对象

```js
function* asyncGenerator() {
    yield 1;
    yield 2;
    yield 3;
}
      
async function() {
    for await (num of asyncGenerator()) {
        console.log(num)
    }
}
```





## ES10

### Array.prototype.flat()

用于将嵌套的数组“拉平”，变成一维的数组。

```js
console.log([1 ,[2, 3]].flat());  //  [1, 2, 3]// 指定转换的嵌套层数 
console.log([1, [2, [3, [4, 5]]]].flat(2));  //  [1, 2, 3, [4, 5]]// 不管嵌套多少层【使用 Infinity 作为深度，展开任意深度的嵌套数组】 
console.log([1, [2, [3, [4, 5]]]].flat(Infinity));  //  [1, 2, 3, 4, 5]
```

### Array.prototype.flatMap()

首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。

观察下面，flatMap是最后压缩成一个新数组

```js
[1, 2, 3, 4].flatMap(x => x * 2);  //  [2, 4, 6, 8]
[1, 2, 3, 4].map(x => x * 2);  //  [2, 4, 6, 8]
//区别
var a = [1,2,3]
var b = [3,4]
var res1 = a.map(a => (b.map(o => [a,o])))
console.log(res1)
var res2 = a.flatMap(a => (b.map(o => [a,o])))
console.log(res2)
//----------------------------------------------
[
  [ [ 1, 3 ], [ 1, 4 ] ],
  [ [ 2, 3 ], [ 2, 4 ] ],
  [ [ 3, 3 ], [ 3, 4 ] ]
]
[ [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 3 ], [ 3, 4 ] ]
```

去除字符串空格

```js
//trim（）
trimStart() / trimEnd() / trimLeft()  / trimRight()//别名(left和right已经不怎么用)
var str='  gjh  '
console.log(str.length)
console.log(str)
console.log(str.trimStart())
console.log(str.trimEnd())
console.log(str.trimLeft())
//7
  gjh  
gjh  
  gjh
```



## ES11

### 控制运算符

空值合并运算符 ?? 提供了一种简短的语法，用来获取列表中第一个“已定义”的变量（译注：即值不是 null 或 undefined 的变量）。

`a ?? b` 的结果是：

+   `a`，如果 `a` 不是 `null` 或 `undefined`，
+   `b`，其他情况。

所以，`x = a ?? b` 是下面这个表达式的简写：

```js
x = (a !== null && a !== undefined) ? a : b;
```

下面是一个更长一点的例子。

假设，我们有一个用户，变量 `firstName`、`lastName` 和 `nickName` 分别对应用户的名字、姓氏和昵称。如果用户决定不输入任何值，那么这些变量都可能是未定义的。

我们想要显示用户的名称：显示这三个变量中的一个，如果都没有设置值，则显示 "Anonymous"。

让我们使用 `??` 运算符选择第一个已定义的变量：

```js
let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// 显示第一个不是 null/undefined 的值
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
```



### gloalthis

JS 语言越来越多被用于各种环境中。除了最常见的浏览器之外，它还可以在服务器、智能手机甚至机器人硬件上运行。

每个环境都有其自己的对象模型，并提供了不同的语法来访问全局对象。例如，在 Web 浏览器中，可以通过window，self或frames访问全局对象。但是，在 Node.js 中，这些属性不存在，而必须使用global。在Web Worker中，只有self可用。

这些不同的全局对象引用方法让 JS 实现跨平台变得非常困难。幸运的是，有一个提案正在制定中，旨在通过引入一个名为globalThis的标准属性来解决这个问题，该属性将在所有环境中可用。

指向全局对象，浏览器下指向 window



### 基本数据类型BIgInt

BigInt是一种特殊的数字类型，它支持任意长度的整数。

要创建一个 bigint，可以在一个整数的末尾添加字符n，或者调用函数 BigInt()。BigInt 函数使用字符串、数字等来创建一个BigInt。

```js
alert(1n+2n);// 3
alert(5n/2n);// 2
我们不能混用 bigint 和常规数字：
alert(1n+2);// Error: Cannot mix BigInt and other types
不支持前置+
let bigint =1n;alert(+bigint );// error
alert(2n>1n);// true
alert(2n>1);// true
```



## ES12

### String.prototype.replaceAll(searchValue, replacement)

原始方法

使用`replace()`方法后，我们常见的一个问题就是`replace()`不能替换所有指定的字符串。因为它仅替换第一次出现的子字符串。

```ruby
'abbc'.replace('b', '_');// 输出则是："a_bc"
```

我们可以看到仅替换了第一个字符串。那么，对于开发人员通常会使用带有global(g)标志的正则表达式进行处理。

另外一种方法就是使用stringObject.split(separator,howmany)结合arrayObject.join(separator)方法处理。

```js
// 如：将中间的加号“+”替换为空。
's=a+b+c'.split('+').join(' ');// 则输出："s=a
```

```js
's=a+b+c'.replaceAll('+', ' ');// => "s=a b c"   全局替换
```

**特殊替换方式**

```js
// 第一种'abcde'.replaceAll('c', '$$')// 第二种'abcde'.replaceAll('c', '$&')
结果是：
// 第一种输出结果"ab$de" 而非 "ab$$de"// 第二种输出结果"abcde" 而非 "ab$&de"
```


若要原样完整输出，则：

```js
'abcde'.replaceAll('c', () => '$$')'abcde'.replaceAll('c', () => '$&')
```



### 数字分隔符号

数字分隔符，可以在数字之间创建可视化分隔符，通过 _ 下划线来分割数字，使数字更具可读性

```js
const money = 1_000_000_000
//等价于
const money = 1000000000    
```





